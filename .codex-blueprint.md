# 🧠 .codex-blueprint.md — Thinking Framework Decision Tree App (TFDT)

## 🧭 Project Mission
This is the “Thinking Framework Decision Tree” (TFDT) app. Its goal is to give a *single user* the strategic reasoning and decision-making power of a Big 4 consulting firm—without needing one.

It acts as a **strategic reasoning assistant**, helping users select the most appropriate framework (e.g. SWOT, Lean, BCG, Design Thinking, Blue Ocean Strategy) based on their challenge, goal, or context.

## 🔍 Core Purpose
- Route user intent through a structured decision tree
- Surface battle-tested frameworks as solutions
- Act as a “thinking prosthetic” for high-agency users navigating complex decisions

## 👤 Target User
- Solo founders, product leads, consultants, students
- Anyone needing fast, structured, expert-level reasoning
- Users who want elite strategy thinking tools, but lightweight and fast

## ⚙️ Current System
- Built in **React.js**
- Recursive TreeNode component renders decision flow
- Frameworks hardcoded in a nested object
- Search feature matches node names to queries
- Content spans business strategy, operations, personal development, organizational psychology, and innovation

## 🧱 What I Want Codex to Build
### Tier 1: Refactor + Modularize
- Extract decision logic into external `frameworks.json` or schema
- Each node: `{ id, name, framework, explanation, type, children[] }`
- Prepare for future localization, filtering, and dynamic loading

### Tier 2: Enhance + Automate
- GPT-assisted explanations per node or framework
- Dynamic user input → inferred path suggestion
- Visualizations per framework (2x2s, matrices, canvases)
- Export brief generator (PDF/Markdown/Notion)

### Tier 3: Expand + Integrate
- Add backend (if needed) using best tool for the job
  - Codex is allowed to suggest alternatives (e.g. Supabase > custom API)
- Enable plug-and-play framework updates via headless CMS or external config
- Consider agent-like logic or chat-augmented UX

## 🔁 Expert Override Mode
You are authorized to challenge and replace any part of the current architecture if it leads to a better, more scalable, or maintainable solution.

You may:
- Recommend a different frontend or backend framework
- Replace local code with managed services (e.g., Supabase, Firebase, Vercel functions)
- Introduce new stack components (e.g., Tailwind, Zustand, tRPC)
- Flatten or rearchitect file structures
- Suggest infrastructure-as-code, hosting shifts, or deployment pipelines

Be decisive and justify each proposed change with a 1-line rationale. If replacement is high-impact, show a phased migration plan.

Assume the user welcomes better solutions, even if it means replacing previous work. No need to preserve legacy if there’s a better way.

## 🔄 GitOps Instructions
Whenever structural changes are made:
- Automatically stage and commit all updated files
- Use clear, conventional commit messages
- Push to the appropriate branch (`main` unless specified)
- If remote isn’t configured, prompt for manual setup or provide next-step instructions

Ask before overwriting staged or uncommitted local changes.

---

## ✅ First Task
> Audit the repo and return:
> 1. A modular architecture plan  
> 2. Proposed file/data structure  
> 3. Tiered next steps (Refactor, Enhance, Expand)  
> Then pause for confirmation.
